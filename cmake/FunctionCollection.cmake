#在编译输出路径创建目标头文件的相对路径访问链接
FUNCTION(X_INSTALL_INCLUDE_LINK)
	SET(oneValueArgs SOURCE DESTION TARGET)
	SET(multiValueArgs HEADER_FILES)
	CMAKE_PARSE_ARGUMENTS("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
	
	FOREACH(HEADER ${_HEADER_FILES})
		GET_FILENAME_COMPONENT(HEADER_REAL_PATH ${HEADER} REALPATH)
	
		FILE(RELATIVE_PATH HEADER_SOURCE_RELATIVE_PATH ${_SOURCE} ${HEADER_REAL_PATH})		
        SET(HEADER_LINK_FILE ${_DESTION}/${_TARGET}/${HEADER_SOURCE_RELATIVE_PATH})
		GET_FILENAME_COMPONENT(HEADER_LINK_FILE_PATH  "${HEADER_LINK_FILE}" DIRECTORY)

		FILE(RELATIVE_PATH HEADER_RELATIVE_PATH ${HEADER_LINK_FILE_PATH} ${HEADER_REAL_PATH})

		FILE(WRITE ${HEADER_LINK_FILE} "#include \"${HEADER_RELATIVE_PATH}\"")
	ENDFOREACH()
ENDFUNCTION()


#增加deployqt任务
FUNCTION(X_ADDTASK_DEPLOY_QT)
	SET(oneValueArgs TARGET)
	CMAKE_PARSE_ARGUMENTS("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
	LIST(FIND X_DEPLOY_QT_TASKLIST ${_TARGET} FIND_RESULT)
	IF (FIND_RESULT EQUAL -1)
		LIST(APPEND X_DEPLOY_QT_TASKLIST ${_TARGET})
		SET(X_DEPLOY_QT_TASKLIST ${X_DEPLOY_QT_TASKLIST} CACHE INTERNAL "")
	ENDIF()
ENDFUNCTION()


#增加构建目标deployqt，用于执行部署qt任务
FUNCTION(X_ADD_TARGET_DEPLOY_QT)
	SET(TASKLIST ${X_DEPLOY_QT_TASKLIST})
	LIST(TRANSFORM TASKLIST PREPEND "\"\$\<TARGET_FILE:")
	LIST(TRANSFORM TASKLIST APPEND "\>\"")
	LIST(JOIN TASKLIST " " TARGET_PATH_LIST)

	LIST(GET X_DEPLOY_QT_TASKLIST 0 FIRST_ELEMENT)
	IF (FIRST_ELEMENT)
		SET(PLUGINDIR " --plugindir \"$<TARGET_FILE_DIR:${FIRST_ELEMENT}>/QtPlugins\"")
		SET(LIBDIR " --libdir \"$<TARGET_FILE_DIR:${FIRST_ELEMENT}>\"")
	ENDIF()
	
	FIND_PROGRAM(DEPLOYQT NAMES windeployqt)
	IF (DEPLOYQT)
		ADD_CUSTOM_TARGET(deployqt
			COMMAND ${DEPLOYQT} $<IF:$<CONFIG:DEBUG>,--debug,--release> --force --no-translations ${LIBDIR} ${PLUGINDIR} ${TARGET_PATH_LIST}
		)
	ENDIF()
ENDFUNCTION()


#增加资源文件(app.rcc)、配置文件(app.json)
FUNCTION(X_ADD_RESOURCE_CONFIG_TRANSLATION)
	SET(oneValueArgs TARGET)
	CMAKE_PARSE_ARGUMENTS("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
	
	#配置文件(app.json)
	ADD_CUSTOM_COMMAND(
		TARGET ${_TARGET}
		POST_BUILD
		COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${_TARGET}>/config/${_TARGET}
		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/mui/app.json
			$<TARGET_FILE_DIR:${_TARGET}>/config/${_TARGET}/app.json
	)
	
	#资源文件(app.rcc)
	FIND_PROGRAM(RCC NAMES rcc)
	IF (RCC)
		ADD_CUSTOM_COMMAND(
			TARGET ${_TARGET}
			POST_BUILD
			COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${_TARGET}>/mui/${_TARGET}
			COMMAND ${RCC} -o $<TARGET_FILE_DIR:${_TARGET}>/mui/${_TARGET}/app.rcc --binary ${CMAKE_CURRENT_SOURCE_DIR}/mui/app.qrc
			COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${_TARGET}>/config/${_TARGET}
			COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/mui/app.json
				$<TARGET_FILE_DIR:${_TARGET}>/config/${_TARGET}/app.json
		)
	ENDIF()

#	#翻译文件(app-zh_CN)
	FIND_PROGRAM(LUPDATE NAMES lupdate)
	FIND_PROGRAM(LRELEASE NAMES lrelease)
	IF (LUPDATE AND LRELEASE)
		ADD_CUSTOM_COMMAND(
			TARGET ${_TARGET}
			POST_BUILD
			COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_SOURCE_DIR}/translations
			COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${_TARGET}>/translations/${_TARGET}
			COMMAND ${LUPDATE} -locations none -target-language zh_CN -recursive 
				-extensions c,cpp,c++,cxx,h,hpp,h++,hxx ${CMAKE_CURRENT_SOURCE_DIR} 
				-ts ${CMAKE_CURRENT_SOURCE_DIR}/translations/app-zh_CN.ts
			COMMAND ${LRELEASE} ${CMAKE_CURRENT_SOURCE_DIR}/translations/app-zh_CN.ts
				-qm $<TARGET_FILE_DIR:${_TARGET}>/translations/${_TARGET}/app-zh_CN.qm
		)
	ENDIF()
ENDFUNCTION()